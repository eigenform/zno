package zno.core.front

import chisel3._
import chisel3.util._
import chisel3.experimental.BundleLiterals._
import chisel3.util.experimental.decode

import zno.common._
import zno.riscv.isa._
import zno.core.uarch._

// Connects the CFM to the midcore. This is the input to instruction decode.
//
// NOTE: The intention here is that the CFM index will be used to recover the 
// program counter/immediate data when needed further down the pipeline.
class CfmBlock(implicit p: ZnoParam) extends Bundle {
  val fetched_bytes = p.fblk.dataWords()
  val cfm_idx = p.cfm.idx()
  val imm_ctl = Vec(p.dec_win.size, new ImmCtl)
}


class InFlightFetchBlock(implicit p: ZnoParam) extends Bundle {
  // The generating control-flow event for this fetch block
  val cfe = new ControlFlowEvent

}

// Structure used to keep track of the work generated by control-flow events.
//
// 1. When a control-flow event occurs, a new entry is created. 
//    The front-end of the machine *must* be stalled when this buffer is full. 
//
// 2. When all relevant instructions in the associated fetch block are retired, 
//    the corresponding entry in this structure is popped. 
//    
//
class InFlightFetchBlockBuffer(implicit p: ZnoParam) extends Module {
  val io = IO(new Bundle {
    // Input architectural control-flow event
    val cfe = Flipped(Decoupled(new ControlFlowEvent))

    val retire_ptr = Flipped(Valid(UInt(log2Ceil(64).W)))
  })

  //val ptr = RingPtr(64)
  //val mem = Mem(64, new InFlightFetchBlock)
  //val new_entry = Wire(new InFlightFetchBlock)
  //new_entry.cfe := io.cfe.bits
  //when (io.arch_cfe.fire && !ptr.empty) {
  //  mem(ptr.enq) := new_entry
  //  ptr.push()
  //}
  //when (io.retire_ptr.fire) {
  //}

}


// 1. Track all fetch blocks (speculative and architectural) moving through
//    the machine 
//
// 2. Perform next-fetch prediction by caching branch information and associated
//    predictions for fetch blocks

class ControlFlowMap(implicit p: ZnoParam) extends Module {
  val io = IO(new Bundle {
    // Input from instruction predecode.
    val pdblk   = Flipped(Decoupled(new PredecodeBlock))

    // Input architectural control-flow event
    val arch_cfe = Flipped(Decoupled(new ArchitecturalCfEvent))

    // Output to midcore/instruction decode
    val cfmblk  = Decoupled(new CfmBlock)

    // Output to instruction fetch unit
    val ftq     = Decoupled(p.FetchBlockAddr())
  })


  // ---------------------------------------------------------
  // Control-flow map storage

  // Defaults
  io.arch_cfe.ready := true.B // FIXME
  io.cfmblk.valid := false.B
  io.cfmblk.bits  := 0.U.asTypeOf(new CfmBlock)

  val tag_arr   = SyncReadMem(p.cfm.size, p.FetchBlockAddr())
  val binfo_arr = SyncReadMem(p.cfm.size, Vec(p.dec_win.size, new BranchInfo))
  val imm_arr   = SyncReadMem(p.cfm.size, Vec(p.dec_win.size, new RvImmData))
  val valid_arr = Reg(Vec(p.cfm.size, Bool()))
  val empty     = WireInit(!this.valid_arr.asUInt.orR)
  val full      = WireInit(this.valid_arr.asUInt.andR)
  val pd_ptr     = Reg(p.cfm.idx())
  val commit_ptr = Reg(p.cfm.idx())

  // We cannot accept a new CFM entry when: 
  //  (a) CFM storage is full
  //  (b) Midcore is not ready to accept a [CfmBlock]?
  io.pdblk.ready  := (!full || !io.cfmblk.ready)

  val pdblk_binfo    = WireInit(VecInit(
    io.pdblk.bits.pdmops.map(mop => mop.binfo)
  ))
  val pdblk_imm_data = WireInit(VecInit(
    io.pdblk.bits.pdmops.map(mop => mop.imm_data)
  ))
  val pdblk_imm_ctl  = WireInit(VecInit(
    io.pdblk.bits.pdmops.map(mop => mop.imm_ctl)
  ))

  when (io.pdblk.fire) {
    // Write a predecode block to the CFM
    valid_arr(pd_ptr) := true.B
    tag_arr.write(pd_ptr, io.pdblk.bits.fblk.addr)
    binfo_arr.write(pd_ptr, pdblk_binfo)
    imm_arr.write(pd_ptr, pdblk_imm_data)
    pd_ptr := pd_ptr + 1.U

    // Send the block to midcore
    io.cfmblk.valid := true.B
    io.cfmblk.bits.fetched_bytes := io.pdblk.bits.fblk.data
    io.cfmblk.bits.cfm_idx := pd_ptr
    io.cfmblk.bits.imm_ctl := pdblk_imm_ctl
  }


  // Impinging architectural events cause a CFM lookup.
  when (io.arch_cfe.fire) {
  }




}






